1 应用场景
  场景1 异步处理:如注册持久化后写入消息队列推送短信消息,邮件消息
  场景2 应用解耦:如订单库存系统可采用推送消息到库存系统,避免库存应用接口失败问题 导致订单失败.
  场景3 流量争锋:如秒杀团购等活动,可以控制限定用户在消息队列中,秒杀业务可根据消息队列中的请求消息做后续处理.
 场景4 消息通讯:点对点消息通信,聊天室
 
2 queue 和 topic 区别
  
2.1点对点（point-to-point，简称PTP）Queue消息传递模型：
        通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。在此传递模型中，
        消息目的地类型是队列（即Destination接口实现类实例由Session接口实现类实例通过调用其createQueue方法并传入队列名称而创建）。
        消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，
        但一条消息仅能传递给一个消息消费者。如果多个消息消费者正在监听队列上的消息
        ，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。
        这种消息传递模型是传统意义上的懒模型或轮询模型。在此模型中，消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得。
2.2发布/订阅（publish/subscribe，简称pub/sub）Topic消息传递模型：
        通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。在此传送模型中，消息目的地类型是主题
        （即Destination接口实现类实例由Session接口实现类实例通过调用其createTopic方法并传入主题名称而创建）。
        消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。
        主题目标也支持长期订阅。长期订阅表示消费者已注册了主题目标，但在消息到达目标时该消费者可以处于非活动状态。
        当消费者再次处于活动状态时，将会接收该消息。如果消费者均没有注册某个主题目标，该主题只保留注册了长期订阅的非活动消费者的消息。
        与PTP消息传递模型不同，pub/sub消息传递模型允许多个主题订阅者接收同一条消息。JMS一直保留消息，直至所有主题订阅者都接收到消息为止。
   pub/sub消息传递模型基本上是一个推模型。在该模型中，消息会自动广播，消息消费者无须通过主动请求或轮询主题的方法来获得新的消息


3 封装发送类型(延时,定时,发送次数,发送类型{文本,图片,附件})


4 与spring集成


5 分布式

